module alu (
    input a[16], //accepts 16 bit input from reg a and reg b
    input b[16],
    input alufn[6], //accepts a 6 bit alufn control signal from control FSM
    output out[16], //output a 16-bit value depending on the alufn control signal
    output z[1], //output a 1-bit z signal
    output v[1], //output a 1-bit v signal
    output n[1] //output a 1-bit n signal
  ) {
  
  //instantiate all the components
  adder adderALU; 
  boolean booleanALU;
  shifter shifterALU;
  compare compareALU;
  multiplier multiplerALU;
  sig mul_or_add[16];   //temp variable to choose add/multiply
  
  always {
    //connect the adder nodes to ALU
    adderALU.alufn = alufn;
    adderALU.a = a;
    adderALU.b = b;
    z = adderALU.z;
    v = adderALU.v;
    n = adderALU.n;
    
    //connect the comparator nodes to the ALU
    compareALU.alufn = alufn;
    compareALU.z = adderALU.z;
    compareALU.v = adderALU.v;
    compareALU.n = adderALU.n;
    
    //connect the boolean nodes to the ALU
    booleanALU.alufn = alufn;
    booleanALU.a = a;
    booleanALU.b = b;
    
    //connect the shifter nodes to the ALU
    shifterALU.alufn = alufn;
    shifterALU.a = a;
    shifterALU.b = b[3:0];
    
    //connect the multipler nodes to the ALU
    multiplerALU.a = a;
    multiplerALU.b = b;
    
    //choose whether to add or multiply
    case(alufn[1]){
      1b0 : mul_or_add = adderALU.out; 
      1b1 : mul_or_add = multiplerALU.out;
      default : mul_or_add = 16h0;
    }
    
    //choose one of the functions of the ALU using ALUFN
    case(alufn[5:4]){
      b00 : out = mul_or_add;
      b01 : out = booleanALU.out;
      b10 : out = shifterALU.out;
      b11 : out = compareALU.out;
      default : out = 16b0;
    }
    
    
  }
}