module booleanTest (
    input clk,  // clock
    input rst,  // reset
    output passes,  
    output completed
  
  ) {
  
  //Declaring all the state to be checked
  .clk(clk) {
    .rst(rst) {
      fsm state = {
      S0, 
      
      AND,OR,XOR,A, 

      COMPLETE
      
      }; 
    }
    dff pass(#INIT(0));
  }
  var expout; // expected output

  boolean bool;

  //Declaring all the I/O for test cases
  always {
    
    // initialise
    bool.a = 16b0;
    bool.b = 16b0;
    bool.alufn = 6b0;
    expout = 16b0;
    completed = 0;
 

    case(state.q) {
      state.AND:
        bool.a = 16b1111111100000000;
        bool.b = 16b1111000011110000;
        expout = 16b1111000000000000;
        bool.alufn = 6b011000;
        pass.d = pass.q & ~|(bool.out ^ 16b1111000000000000);
        completed = 0;

        state.d = state.OR; //auto proceed to the next test state regardless
   
      
      state.OR:
        bool.a = 16b1111111100000000;
        bool.b = 16b1111000011110000;
        expout = 16b1111111111110000;
        bool.alufn = 6b011110;
        pass.d = pass.q & ~|(bool.out ^ 16b1111111111110000);
        completed = 0;

        state.d = state.XOR; //auto proceed to the next test state regardless

     
      state.XOR:
        bool.a = 16b1111111100000000;
        bool.b = 16b1111000011110000;
        expout = 16b0000111111110000;
        bool.alufn = 6b010110;
        pass.d = pass.q & ~|(bool.out ^ 16b0000111111110000);
        completed = 0;

        state.d = state.A; //auto proceed to the next test state regardless

      
      state.A:
        bool.a = 16b1111111100000000;
        bool.b = 16b1110000011111100;
        expout = 16b1111111100000000;
        bool.alufn = 6b011010;
        pass.d = pass.q & ~|(bool.out ^ 16b1111111100000000);
        completed = 0;

        state.d = state.COMPLETE;

      state.COMPLETE:
         completed = 1;
      default:
         completed = 0;
     }
     passes = pass.q;


  }

}

