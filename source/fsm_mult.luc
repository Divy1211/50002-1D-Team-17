/**
* FSM Module that tests the multiplier with hard coded test cases and outputs
*
* @input clk       - the default clock input
* @input rst       - the default reset input
*
* @output complete - 1 bit output to signify that testing is complete
* @output cases    - 6 bit output to signify the result of each test case
*/
module fsm_mult (
    input clk,
    input rst,
    output complete,
    output cases[6]
) {
  .clk(clk) {
    .rst(rst) {
      fsm test_case = {ZERO, ONE, TWO, THREE, FOUR, FIVE, SIX, COMPLETE};
    }
  }
  
  // creating a test signal which can be tied to the @output cases
  sig test[6];
  multiplier mult;

  always {
    complete = 0;
    mult.a = 0;
    mult.b = 0;

    case(test_case.q) {
      test_case.ZERO:
        test = 6b0;
      test_case.ONE:
        mult.a = 10;
        mult.b = 2;
        test = test;
        test[0] = ~|(mult.out ^ 16d20);
        test_case.d = test_case.ONE;
      test_case.TWO:
        mult.a = 500;
        mult.b = 500;
        test = test;
        test[1] = ~|(mult.out ^ -16d12144);
        test_case.d = test_case.TWO;
      test_case.THREE:
        mult.a = -2;
        mult.b = 4;
        test = test;
        test[2] = ~|(mult.out ^ -16d8);
        test_case.d = test_case.THREE;
      test_case.FOUR:
        mult.a = 2;
        mult.b = -4;
        test = test;
        test[3] = ~|(mult.out ^ -16d8);
        test_case.d = test_case.FOUR;
      test_case.FIVE:
        mult.a = -10;
        mult.b = -2;
        test = test;
        test[4] = ~|(mult.out ^ 16d20);
        test_case.d = test_case.FIVE;
      test_case.SIX:
        mult.a = -500;
        mult.b = 500;
        test = test;
        test[5] = ~|(mult.out ^ 16d12144);
        test_case.d = test_case.COMPLETE;
      test_case.COMPLETE:
        test = test;
        complete = 1;
      default:           // this should never happen, if it does something has gone very wrong
        test = 0;
    }
    cases = test;
  }
}
