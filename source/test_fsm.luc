/**
* Tests the shifter with hard coded test cases and outputs
*
* @input clk                       - the default clock input
* @input rst                       - the default reset input
* @input error                     - if we want to simulate an error
*
* @output unit_passed              - if a unit passes all its test cases, the bit corresponding to it is set to 1
* @output test_casses_passed       - 16 bit output to signify the result of each test case (max 16 test cases per unit)
* @output complete                 - flag to indicate when the testing is complete
*/
module test_fsm (
    input clk,
    input rst,
    input error,

    output unit_passed[7],
    output test_cases_passed[16],
    output complete
) {
  .clk(clk) {
    .rst(rst) {
      fsm test_unit = {ADDER1, ADDER2, BOOLEAN, COMPARE, MULTIPLIER1, MULTIPLIER2, SHIFTER, DONE};
      dff counter[31](#INIT(0)); // the high 5 bits of this are used as a counter for test cases
    }
  }
  
  .test_case(counter.q[30:26]) {    
    rom_adder1      rom1;
    rom_adder2      rom2;
    rom_boolean     rom3;
    rom_comparator  rom4;
    rom_multiplier1 rom5;
    rom_multiplier2 rom6;
    rom_shifter     rom7;
  }

  // standard alu inputs
  sig a[16];
  sig b[16];
  sig alufn[6];

  // expected output, z, v, b
  sig exp_out[16];
  sig exp_z;
  sig exp_v;
  sig exp_n;

  // expected error flag from the multiplier in case of a division by 0
  // 0 if the operation is not multiplication
  sig exp_e;

  sig unit_passed_s[7];
  sig test_cases_passed_s[16];
    
  alu test_alu(.a(a), .b(b), .alufn(alufn));

  always {
    counter.d = counter.q+1;

    complete = 0;
    alufn = 0;
    exp_out = 0;
    exp_z = 0;
    exp_v = 0;
    exp_n = 0;
    exp_e = 0;

    // since the counter is increased every clock cycle,
    // and bitss 30-26 are used to count, it gives us a counter
    // which approximately increases once every 1.34 s
    if(counter.q[30:26] == 0) {
      test_cases_passed_s = 16b0;
    }

    test_cases_passed_s = test_cases_passed_s;
    unit_passed_s = unit_passed_s;

    // In each cycle, the test cases indicated by the counter's top 5 bits
    // is loaded into the signals using this switch-case statement here
    case(test_unit.q) {
      test_unit.ADDER1:
        a = rom1.a;
        b = rom1.b;
        alufn = rom1.alufn;
        exp_out = rom1.exp_out;
        exp_z = rom1.exp_z;
        exp_v = rom1.exp_v;
        exp_n = rom1.exp_n;
        unit_passed_s[0] = 0;

        // if all the test cases of a ROM have been checked
        // determine if all of them were a pass and set the corresponding
        // unit_passed flag accordingly. Advance the FSM to the next state
        if(counter.q[30:26] == rom1.num_cases-1) {
          unit_passed_s[0] = &test_cases_passed_s[0:rom1.num_cases-1];
          counter.d = 0;
          test_unit.d = test_unit.ADDER2;
        }
      test_unit.ADDER2:
        a = rom2.a;
        b = rom2.b;
        alufn = rom2.alufn;
        exp_out = rom2.exp_out;
        exp_z = rom2.exp_z;
        exp_v = rom2.exp_v;
        exp_n = rom2.exp_n;
        unit_passed_s[1] = 0;
        if(counter.q[30:26] == rom2.num_cases-1) {
          unit_passed_s[1] = &test_cases_passed_s[0:rom2.num_cases-1];
          counter.d = 0;
          test_unit.d = test_unit.BOOLEAN;
        }
      test_unit.BOOLEAN:
        a = rom3.a;
        b = rom3.b;
        alufn = rom3.alufn;
        exp_out = rom3.exp_out;
        exp_z = rom1.exp_z;
        exp_v = rom1.exp_v;
        exp_n = rom1.exp_n;
        unit_passed_s[2] = 0;
        if(counter.q[30:26] == rom3.num_cases-1) {
          unit_passed_s[2] = &test_cases_passed_s[0:rom3.num_cases-1];
          counter.d = 0;
          test_unit.d = test_unit.COMPARE;
        }
      test_unit.COMPARE:
        a = rom4.a;
        b = rom4.b;
        alufn = rom4.alufn;
        exp_out = rom4.exp_out;
        exp_z = rom4.exp_z;
        exp_v = rom4.exp_v;
        exp_n = rom4.exp_n;
        unit_passed_s[3] = 0;
        if(counter.q[30:26] == rom4.num_cases-1) {
          unit_passed_s[3] = &test_cases_passed_s[0:rom4.num_cases-1];
          counter.d = 0;
          test_unit.d = test_unit.MULTIPLIER1;
        }
      test_unit.MULTIPLIER1:
        a = rom5.a;
        b = rom5.b;
        alufn = rom5.alufn;
        exp_out = rom5.exp_out;
        exp_z = rom1.exp_z;
        exp_v = rom1.exp_v;
        exp_n = rom1.exp_n;
        unit_passed_s[4] = 0;
        if(counter.q[30:26] == rom5.num_cases-1) {
          unit_passed_s[4] = &test_cases_passed_s[0:rom5.num_cases-1];
          counter.d = 0;
          test_unit.d = test_unit.MULTIPLIER2;
        }
      test_unit.MULTIPLIER2:
        a = rom6.a;
        b = rom6.b;
        alufn = rom6.alufn;
        exp_out = rom6.exp_out;
        exp_z = rom1.exp_z;
        exp_v = rom1.exp_v;
        exp_n = rom1.exp_n;
        unit_passed_s[5] = 0;
        if(counter.q[30:26] == rom6.num_cases-1) {
          unit_passed_s[5] = &test_cases_passed_s[0:rom6.num_cases-1];
          counter.d = 0;
          test_unit.d = test_unit.SHIFTER;
        }
      test_unit.SHIFTER:
        a = rom7.a;
        b = rom7.b;
        alufn = rom7.alufn;
        exp_out = rom7.exp_out;
        exp_z = rom1.exp_z;
        exp_v = rom1.exp_v;
        exp_n = rom1.exp_n;
        unit_passed_s[6] = 0;
        if(counter.q[30:26] == rom7.num_cases-1) {
          unit_passed_s[5] = &test_cases_passed_s[0:rom7.num_cases-1];
          counter.d = 0;
          test_unit.d = test_unit.DONE;
        }
      test_unit.DONE:
        // fix the counter to 0 and mark the testing as completed
        counter.d = 0;
        complete = 1;
    }

    test_cases_passed_s[counter.q[30:26]] = ~|(test_alu.out ^ exp_out) & ~|({test_alu.z, test_alu.v, test_alu.n, test_alu.e} ^ {exp_z, exp_v, exp_n, exp_e});

    test_cases_passed = test_cases_passed_s;
    unit_passed = unit_passed_s;
  }
}
