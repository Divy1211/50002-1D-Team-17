module manual_test (
    input clk,  // clock
    input rst,  // reset
    input io_shield_button [5],    // 5 buttons on IO Shield
    input io_shield_dip [3][8],    // DIP switches on IO Shield
    
    //outputs from the alu, to be reflected on the IO element
    output out[16],
    output z[1],
    output v[1],
    output n[1],
    output e[1],
    output manual_state[4]
  ) {

  .clk(clk) {
    .rst(rst) {
      fsm state = {LISTEN_A, LISTEN_B, LISTEN_ALUFN, CALC};
    dff aInput[16];
    dff bInput[16];
    dff alufnInput[6];
    dff dip_in[16]; // the 16 bit input given by the DIP switches
    }
  }
  
  alu aluTestInstance;
  
  always {
    manual_state = 4b0;
    aluTestInstance.a = aInput.q;
    aluTestInstance.b = bInput.q;
    aluTestInstance.alufn = alufnInput.q;
    
    //inital values of the output, updated in state: CALC
    out = 0;
    z = 0;
    v = 0;
    n = 0;
    e = 0;
    case (state.q) {
      state.LISTEN_A:
      manual_state[0] = 1b1;
        dip_in.d = c{io_shield_dip[1], io_shield_dip[0]}; // using the 2 rightmost rows of DIP switches to input the values
        if (io_shield_button[0]) {                       // if the io_shield_button[0] is pressed, save the input from the DIP switches and move on to the next state
          aInput.d = dip_in.q;
          state.d = state.LISTEN_B;
        }
 
      state.LISTEN_B:
      manual_state[1] = 1b1;
        aInput.d = aInput.q;                             // allow aInput to store data of input a
        dip_in.d = c{io_shield_dip[1], io_shield_dip[0]}; // using the 2 rightmost rows of DIP switches to input the values
        if (io_shield_button[2]) {                        // if the io_shield_button[2] is pressed, move on to the next state, avoid using the same button as previous state to prevent the fsm from "zooming" past state LISTEN_B
          bInput.d = dip_in.q;
          state.d = state.LISTEN_ALUFN;
        }
          
      state.LISTEN_ALUFN:
      manual_state[2] = 1b1;
        bInput.d = bInput.q;               // allow bInput to store data of input b
        dip_in.d = io_shield_dip[0][5:0];  // using the 2 rightmost rows of DIP switches to input the values
        if (io_shield_button[0]) {          // if the io_shield_button[0] is pressed, move on to the next state
          alufnInput.d = dip_in.q[5:0];
          state.d = state.CALC;
          }
        
      state.CALC:
        alufnInput.d = alufnInput.q; // allow alufnInput to store data of input alufn
        
        //connect the nodes of the alu instance to the DFFs containing the data
        aluTestInstance.a = aInput.q;
        aluTestInstance.b = bInput.q;
        aluTestInstance.alufn = alufnInput.q;
        
        out = aluTestInstance.out;
        z = aluTestInstance.z;
        v = aluTestInstance.v;
        n = aluTestInstance.n;
        e = aluTestInstance.e;
        
        if (io_shield_button[2]) {
          manual_state = 4b0;  // if the io_shield_button[0] is pressed, move return to initial state
          state.d = state.LISTEN_A; //avoid using the same button as previous state to prevent the fsm from "zooming" past state CALC
        }
    }
  }
}
